 John Ioannidis  Aviel D. Rubin  AT&T Labs – Research, Florham Park, NJ {ji,rubin}@research.att.com  We implemented an attack against WEP, the link-layer security protocol for 802.11 networks. The attack was described in a recent paper by Fluhrer, Mantin, and Shamir. With our implementation, and permission of the network administrator, we were able to recover the 128 bit secret key used in a production network, with a pas- sive attack. The WEP standard uses RC4 IVs improperly, and the attack exploits this design failure. This paper describes the attack, how we implemented it, and some optimizations to make the attack more efﬁcient. We con- clude that 802.11 WEP is totally insecure, and we pro- vide some recommendations.  1 
 In this paper we address the problem of secure commu- nication and authentication in ad-hoc wireless networks. This is a difﬁcult problem, as it involves bootstrapping trust between strangers. We present a user-friendly solution, which provides secure authentication using almost any es- tablished public-key-based key exchange protocol, as well as inexpensive hash-based alternatives. In our approach, devices exchange a limited amount of public information over a privileged side channel, which will then allow them to complete an authenticated key exchange protocol over the wireless link. Our solution does not require a public key infrastructure, is secure against passive attacks on the privileged side channel and all attacks on the wireless link, and directly captures users’ intuitions that they want to talk to a particular previously unknown device in their physical proximity. We have implemented our system in Java for a variety of different devices, communication media, and key exchange protocols.  1. 
 In this paper we describe our experiences with build- ing BlueBox, a host based intrusion detection system. Our approach can be viewed as creating an infrastructure for deﬁning and enforcing very ﬁne grained process capabili- ties in the kernel. These capabilities are speciﬁed as a set of rules (policies) for regulating access to system resources on a per executable basis. The language for expressing the rules is intuitive and sufﬁciently expressive to effectively capture security boundaries.  We have prototyped our approach on Linux 2.2.14 kernel, and have built rule templates for popular daemons such as Apache 2.0 and wu-ftpd. We are validating our design by testing against a comprehensive database of known at- tacks. Our system has been designed to minimize the kernel changes and performance impact and thus can be ported easily to new kernels. We will discuss the motivation and rationale behind BlueBox, its design, implementation on Linux, and related work.  1 
 Pushback is a mechanism for defending against dis- tributed denial-of-service (DDoS) attacks. DDoS attacks are treated as a congestion-control problem, but because most such congestion is caused by malicious hosts not obey- ing traditional end-to-end congestion control, the problem must be handled by the routers. Functionality is added to each router to detect and preferentially drop packets that probably belong to an attack. Upstream routers are also notiﬁed to drop such packets (hence the term Pushback) in order that the router’s resources be used to route legitimate trafﬁc. In this paper we present an architecture for Push- back, its implementation under FreeBSD, and suggestions for how such a system can be implemented in core routers.  1. 
 tion 10 compares our scheme with related work. Finally Section 11 concludes.  This paper addresses the identiﬁer ownership problem. It does so by using characteristics of Statistic Uniqueness and Cryptographic Veriﬁability (SUCV) of certain enti- ties which this document calls SUCV Identiﬁers and Ad- dresses. Their characteristics allow them to severely limit certain classes of denial of service attacks and hijacking attacks. SUCV addresses are particularly applicable to solve the address ownership problem that hinders mecha- nisms like Binding Updates in Mobile IPv6.  keywords: Security, Mobile IPv6, Address ownership.  1 
 This paper explores practical and conceptual im- plications of using Server-Aided Signatures (SAS). SAS is a signature method that relies on partially- trusted servers for generating public key signatures for regular users. Besides its two primary goals of 1) aiding small, resource-limited devices in comput- ing heavy-weight (normally expensive) digital sig- natures and 2) fast certiﬁcate revocation, SAS also oﬀers signature causality and has some interesting features such as built-in attack detection for users and DoS resistance for servers.  1 
This paper discusses considerations for certificate issuing systems and certificate processing applications, and directory systems in environments that employ nonhierarchical public key infrastructures (PKIs). The observations and recommendations here, while applicable to almost any non-hierarchical PKI, are most relevant to situations where the establishment of interoperability among the PKIs of disparate organizations is a primary goal. They are based on our work with a PKI interoperability testbed comprised of a bridge certification authority (CA) interconnecting multiple PKIs based on CA products from several vendors. Our view is that the more sophisticated aspects of X.509 certificate issuance and processing (e.g., certificate policies and mappings, name constraints) are tools that allow the PKI to establish the limits of security interoperability between organizations [1]. Consequently, we believe that the extensions for these X.509 features should be routinely populated by certificate issuing systems, and expected and processed by certificate processing applications. The goal of the recommendations herein is to promote interoperability among the PKI relying parties, while still allowing the owning organizations to maintain security control.
 including expressivity,  In this paper, we present a novel approach to delegation in computer systems. We exploit mobile code capabilities of today’s systems to build active certiﬁcates: crypto- graphically signed mobile agents that implement delegation policy. Active certiﬁcates arrive at a new combination of properties, transparency, and ofﬂine operation, that is not available in existing systems. These properties make active certiﬁcates powerful tools to express delegation. Active certiﬁcates can also be used as a mechanism to implement complex policy systems, such as public key infrastructures; systems built in this way are easily extensible and interoperable. A prototype implementation of active certiﬁcates has been built as part of the Ninja [17] project.  1 
In this paper we present PAMINA (Privilege Administration and Management INfrAstructure), a privilege management system using authorization certificates. Our system supports distributed environments where autonomous authorities can manage and delegate privileges in accordance with their own policies. We introduce Improved Certification Verification Trees (I-CVTs) that guarantee very efficient and trustworthy certificate management. I-CVTs can provide undeniable proofs for the non-existence of a given certificate in contrast to CVTs as proposed in [1]. As a result, each authority can store its own I-CVT in a central, non-trusted, and replicable database. This database provides authenticated verifiers with basically only those certificates that are required to determine whether a user should be granted access to a resource or not. Since the system implements the pull model, clients need not to be involved in the access control decision process. PAMINA handles delegation trees instead of simple delegation chains because authorities can delegate privileges in one certificate that were assigned to them by several certificates. In the prototype that we describe here, PAMINA manages certificates based on X.509. 
 TLS is the protocol of choice for securing today’s e- commerce and online transactions, but adding TLS to a web server imposes a signiﬁcant overhead relative to an insecure web server on the same platform. We perform a comprehensive study of the performance costs of TLS. Our methodology is to proﬁle TLS web servers with trace- driven workloads, replacing individual components inside TLS with no-ops, and measuring the observed increase in server throughput. We estimate the relative costs of each component within TLS, predicting the areas for which fu- ture optimizations would be worthwhile. Our results we show that RSA accelerators are effective for e-commerce site workloads , because they experience low TLS ses- sion reuse. Accelerators appear to be less effective for sites where all the requests are handled by a TLS server, thus having higher session reuse rate; investing in a faster CPU might prove more effective.  1. 
 We propose a new, “fast-track” handshake mechanism for TLS. A fast-track client caches a server’s public pa- rameters and negotiated parameters in the course of an initial, enabling handshake. These parameters need not be resent on subsequent handshakes. The new mecha- nism reduces both network trafﬁc and the number of round trips, and requires no additional server state. These sav- ings are most useful in high latency environments such as wireless networks. We include a rollback mechanism to al- low a server to gracefully revert to an ordinary TLS hand- shake when needed. Our design is fully backwards com- patible: fast-track clients can interoperate with servers unaware of fast-track and vise versa. We have imple- mented our proposal to demonstrate the savings in net- work trafﬁc and round trips.  1. 
Many business transactions on the Internet occur between strangers, that is, between entities with no prior relationship and no common security domain. Traditional security approaches based on identity or capabilities do not solve the problem of establishing trust between strangers. New approaches to trust establishment are required that are secure, scalable, and portable. One new approach to mutual trust establishment is trust negotiation, the bilateral exchange of digital credentials to establish trust gradually. This paper describes the Trust Negotiation in TLS (TNT) protocol, an extension to the TLS handshake protocol that incorporates recent advances in trust negotiation into TLS to provide advanced client/server authentication in TLS. In this paper we describe the current limitations in TLS client/server authentication with respect to trust establishment, and show how the TNT protocol overcomes them. We also describe our implementation of TNT, built using PureTLS, a Java TLS package that is freely available. This implementation is the first to provide confidential trust negotiation, verification of private keys during trust negotiation, and a single trust negotiation protocol supporting interoperable trust negotiation strategies.
