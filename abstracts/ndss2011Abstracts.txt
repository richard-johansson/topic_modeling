 We explore the threat of smartphone malware with ac- cess to on-board sensors, which opens new avenues for il- licit collection of private information. While existing work shows that such “sensory malware” can convey raw sen- sor data (e.g., video and audio) to a remote server, these approaches lack stealthiness, incur signiﬁcant communica- tion and computation overhead during data transmission and processing, and can easily be defeated by existing pro- tections like denying installation of applications with ac- cess to both sensitive sensors and the network. We present Soundcomber, a Trojan with few and innocuous permis- sions, that can extract a small amount of targeted private information from the audio sensor of the phone. Using targeted proﬁles for context-aware analysis, Soundcomber intelligently “pulls out” sensitive data such as credit card and PIN numbers from both tone- and speech-based inter- action with phone menu systems. Soundcomber performs efﬁcient, stealthy local extraction, thereby greatly reducing the communication cost for delivering stolen data. Sound- comber automatically infers the destination phone number by analyzing audio, circumvents known security defenses, and conveys information remotely without direct network access. We also design and implement a defensive architec- ture that foils Soundcomber, identify new covert channels speciﬁc to smartphones, and provide a video demonstration of Soundcomber.  1 
 We present a cryptographic framework to achieve access control, privacy of social relations, secrecy of resources, and anonymity of users in social networks. We illustrate our technique on a core API for social networking, which includes methods for establishing social relations and for sharing resources. The cryptographic protocols implement- ing these methods use pseudonyms to hide user identi- ties, signatures on these pseudonyms to establish social re- lations, and zero-knowledge proofs of knowledge of such signatures to demonstrate the existence of social relations without sacriﬁcing user anonymity. As we do not put any constraints on the underlying social network, our frame- work is generally applicable and, in particular, constitutes an ideal plug-in for decentralized social networks.  We analyzed the security of our protocols by developing formal deﬁnitions of the aforementioned security properties and by verifying them using ProVerif, an automated theo- rem prover for cryptographic protocols. Finally, we built a prototypical implementation and conducted an experimen- tal evaluation to demonstrate the efﬁciency and the scala- bility of our framework.  1. 
 We study privacy-preserving tests for proximity: Alice can test if she is close to Bob without either party reveal- ing any other information about their location. We describe several secure protocols that support private proximity test- ing at various levels of granularity. We study the use of “location tags” generated from the physical environment in order to strengthen the security of proximity testing. We implemented our system on the Android platform and re- port on its effectiveness. Our system uses a social network (Facebook) to manage user public keys.  1  
 We demonstrate relay attacks on Passive Keyless Entry and Start (PKES) systems used in modern cars. We build two efﬁcient and inexpensive attack realizations, wired and wireless physical-layer relays, that allow the attacker to en- ter and start a car by relaying messages between the car and the smart key. Our relays are completely independent of the modulation, protocol, or presence of strong authenti- cation and encryption. We perform an extensive evaluation on 10 car models from 8 manufacturers. Our results show that relaying the signal in one direction only (from the car to the key) is sufﬁcient to perform the attack while the true distance between the key and car remains large (tested up to 50 meters, non line-of-sight). We also show that, with our setup, the smart key can be excited from up to 8 meters. This removes the need for the attacker to get close to the key in order to establish the relay. We further analyze and discuss critical system characteristics. Given the generality of the relay attack and the number of evaluated systems, it is likely that all PKES systems based on similar designs are also vulnerable to the same attack. Finally, we propose im- mediate mitigation measures that minimize the risk of relay attacks as well as recent solutions that may prevent relay attacks while preserving the convenience of use, for which PKES systems were initially introduced.
 The proliferation of personal wireless devices requires secure connection between them. While it is easy to se- curely pair electronic devices by wires, it is very challeng- ing to pair them wirelessly when they have no prior asso- ciation. We propose Good Neighbor, a novel scheme that securely pairs nearby wireless devices by exploiting mul- tiple antennas built in them. Our scheme requires neither shared secrets nor out-of-band channels (e.g., audio, vi- sual, keyboard, etc.) between the pairing devices. It only requires that the receiver has multiple antennas and that the sender can be placed nearby the receiver. Our scheme is based on the propagation characteristic of the wireless signal that the power of the received signal is inversely proportional to some exponent of the distance between the sender and receiver. When a nearby sender moves very close to one antenna on the receiver, the receiver can ob- serve a large difference between the signal strength mea- sured on its two antennas, whereas a faraway sender would be unable to induce such a large difference. We validate our scheme through theoretical analysis and experimental measurements. We discuss the factors that may affect our scheme — including antenna gain, received signal strength (RSS) saturation, dynamic rate adaptation, and multipath effects — and how to mitigate them. Finally, we demon- strate the practicality of our scheme by implementing and evaluating a prototype.  1 
 Kernel extensions are widely used by attackers to com- promise the operating system kernel. With the presence of various untrusted extensions, it remains a challenging prob- lem to comprehensively preserve the integrity of OS kernels in a practical and generic way. In this paper, we present HUKO, a hypervisor-based integrity protection system de- signed to protect commodity OS kernels from untrusted ex- tensions. In HUKO system, untrusted kernel extensions can safely run to provide desired functionalities. The behaviors of untrusted extensions, however, are conﬁned by manda- tory access control policies, which signiﬁcantly limit the attacker’s ability to compromise the integrity of the ker- nel. To guarantee multi-aspect protection and enforcement, HUKO leverages hardware assisted paging to transparently isolate untrusted extensions from the OS kernel. Moreover, HUKO overcomes the challenge of mediation overhead by introducing a novel design named subject-aware protection state transition to eliminate unnecessary privilege transi- tions caused by mediating allowed accesses. Our approach is practical because it requires little change for either OS kernel or extensions, and it can inherently support multiple commodity operating systems and legacy extensions. We have implemented a prototype of HUKO based on the open source Xen hypervisor. The evaluation results show that HUKO can comprehensively protect the integrity for both Linux and Windows kernel from various kinds of malicious extensions with an acceptable performance cost.  1  
 Recent malware instances execute completely in the kernel as drivers; they do not contain any user-level ma- licious processes. This design evades the system call monitoring used by many software security solutions, in- cluding malware analyzers and host-based intrusion de- tectors that track only user-level processes. To trace the behavior of kernel malware instances, we design and im- plement a hypervisor-based system called Gateway that monitors kernel APIs invoked by drivers. Gateway cre- ates a hardened, non-bypassable monitoring interface by isolating drivers in an address space separate from the kernel. To overcome the performance degradation introduced by switches between these separate address spaces, our design rewrites binary kernel and driver code at runtime and generates new code on demand to optimize the address space transition speed. Our exper- imental measurements show performance overheads of 10% or better, with many overheads less than 1%. Our security evaluation shows that Gateway is able to mon- itor all kernel APIs invoked by malicious drivers across its non-bypassable interface.  1. 
 Brute force scanning of kernel memory images for ﬁnd- ing kernel data structure instances is an important func- tion in many computer security and forensics applications. Brute force scanning requires effective, robust signatures of kernel data structures. Existing approaches often use the value invariants of certain ﬁelds as data structure signa- tures. However, they do not fully exploit the rich points- to relations between kernel data structures. In this pa- per, we show that such points-to relations can be lever- aged to generate graph-based structural invariant signa- tures. More speciﬁcally, we develop SigGraph, a frame- work that systematically generates non-isomorphic signa- tures for data structures in an OS kernel. Each signature is a graph rooted at a subject data structure with its edges reﬂecting the points-to relations with other data structures. Our experiments with a range of Linux kernels show that SigGraph-based signatures achieve high accuracy in recog- nizing kernel data structure instances via brute force scan- ning. We further show that SigGraph achieves better robust- ness against pointer value anomalies and corruptions, with- out requiring global memory mapping and object reachabil- ity. We demonstrate that SigGraph can be applied to kernel memory forensics, kernel rootkit detection, and kernel ver- sion inference.  1  
 In this work, we introduce the Coordinated Cross Plane Session Termination, or CXPST, attack, a distributed denial of service attack that attacks the control plane of the In- ternet. CXPST extends previous work that demonstrates a vulnerability in routers that allows an adversary to discon- nect a pair of routers using only data plane trafﬁc. By care- fully choosing BGP sessions to terminate, CXPST generates a surge of BGP updates that are seen by nearly all core routers on the Internet. This surge of updates surpasses the computational capacity of affected routers, crippling their ability to make routing decisions.  In this paper we show how an adversary can attack mul- tiple BGP sessions simultaneously and measure the impact these session failures have on the control plane of the In- ternet. We directly simulate the BGP activity resulting from this attack and compute the impact those messages have on router processing loads. Through simulations we show that botnets on the order of 250, 000 nodes can increase process- ing delays from orders of microseconds to orders of hours. We also propose and validate a defense against CXPST. Through simulation we demonstrate that current defenses are insufﬁcient to stop CXPST. We propose an alternative, low cost, defense that is successful against CXPST, even if only the top 10% of Autonomous Systems by degree deploy it. Additionally, we consider more long term defenses that stop not only CXPST, but similar attacks as well.  1  
 The domain name service (DNS) plays an important role in the operation of the Internet, providing a two-way map- ping between domain names and their numerical identiﬁers. Given its fundamental role, it is not surprising that a wide variety of malicious activities involve the domain name ser- vice in one way or another. For example, bots resolve DNS names to locate their command and control servers, and spam mails contain URLs that link to domains that resolve to scam servers. Thus, it seems beneﬁcial to monitor the use of the DNS system for signs that indicate that a certain name is used as part of a malicious operation.  In this paper, we introduce EXPOSURE, a system that employs large-scale, passive DNS analysis techniques to detect domains that are involved in malicious activity. We use 15 features that we extract from the DNS trafﬁc that al- low us to characterize different properties of DNS names and the ways that they are queried.  Our experiments with a large, real-world data set con- sisting of 100 billion DNS requests, and a real-life deploy- ment for two weeks in an ISP show that our approach is scalable and that we are able to automatically identify un- known malicious domains that are misused in a variety of malicious activity (such as for botnet command and control, spamming, and phishing).  1  
 Even the most advanced reverse engineering techniques and products are weak in recovering data structures in stripped binaries—binaries without symbol tables. Unfor- tunately, forensics and reverse engineering without data structures is exceedingly hard. We present a new solution, known as Howard, to extract data structures from C binaries without any need for symbol tables. Our results are signiﬁ- cantly more accurate than those of previous methods — suf- ﬁciently so to allow us to generate our own (partial) symbol tables without access to source code. Thus, debugging such binaries becomes feasible and reverse engineering becomes simpler. Also, we show that we can protect existing binaries from popular memory corruption attacks, without access to source code. Unlike most existing tools, our system uses dy- namic analysis (on a QEMU-based emulator) and detects data structures by tracking how a program uses memory.  1. 
 The Component Object Model (COM) facilitates the creation of software plugins for applications running in Microsoft Windows. ActiveX is a common instantiation of this infrastructure, and uses COM to create plugins for Internet Explorer. As vulnerabilities in COM ob- jects included in the installation of Windows have been found, Microsoft has responded by blacklisting their use by speciﬁc applications. In this paper, we demonstrate that the defense mechanisms protecting vulnerable COM objects can be easily circumvented. Speciﬁcally, our at- tack exploits systemic transitive trust among COM ob- jects and allows for the instantiation and exploitation of any of several hundred known ﬂawed controls. After demonstrating this weakness on fully patched Windows XP, Windows Vista and Windows 7 machines, we design and implement a system-wide enforcement architecture called COMBlocker, which checks the instantiation of COM objects against a global policy. We then show that COMBlocker is an effective mitigation for such attacks while imposing minimal overhead (approximately 0.5ms per policy check). In so doing, our techniques make the exploitation of default COM objects signiﬁcantly more difﬁcult.  1  
 A recurring problem in security is reverse engineering binary code to recover high-level language data abstrac- tions and types. High-level programming languages have data abstractions such as buffers, structures, and local vari- ables that all help programmers and program analyses rea- son about programs in a scalable manner. During compi- lation, these abstractions are removed as code is translated down to operations on registers and one globally addressed memory region. Reverse engineering consists of “undoing” the compilation to recover high-level information so that programmers, security professionals, and analyses can all more easily reason about the binary code.  In this paper we develop novel techniques for reverse engineering data type abstractions from binary programs. At the heart of our approach is a novel type reconstruction system based upon binary code analysis. Our techniques and system can be applied as part of both static or dynamic analysis, thus are extensible to a large number of security settings. Our results on 87 programs show that TIE is both more accurate and more precise at recovering high-level types than existing mechanisms.  1 
 The automatic exploit generation challenge is given a program, automatically ﬁnd vulnerabilities and gener- ate exploits for them. In this paper we present AEG, the ﬁrst end-to-end system for fully automatic exploit gener- ation. We used AEG to analyze 14 open-source projects and successfully generated 16 control ﬂow hijacking ex- ploits. Two of the generated exploits (expect-5.43 and htget-0.93) are zero-day exploits against unknown vul- nerabilities. Our contributions are: 1) we show how exploit generation for control ﬂow hijack attacks can be modeled as a formal veriﬁcation problem, 2) we pro- pose preconditioned symbolic execution, a novel tech- nique for targeting symbolic execution, 3) we present a general approach for generating working exploits once a bug is found, and 4) we build the ﬁrst end-to-end sys- tem that automatically ﬁnds vulnerabilities and gener- ates exploits that produce a shell.  1  
In the last twenty years, web applications have grown from simple, static pages to complex, full-fledged dynamic applications. Typically, these applications are built using heterogeneous technologies and consist of code that runs both on the client and on the server. Even simple web applications today may accept and process hundreds of different HTTP parameters to be able to provide users with interactive services. While injection vulnerabilities such as SQL injection and cross-site scripting are well-known and have been intensively studied by the research community, a new class of injection vulnerabilities called HTTP Parameter Pollution (HPP) has not received as much attention. If a web application does not properly sanitize the user input for parameter delimiters, exploiting an HPP vulnerability, an attacker can compromise the logic of the application to perform either client-side or server-side attacks. In this paper, we present the first automated approach for the discovery of HTTP Parameter Pollution vulnerabilities in web applications. Using our prototype implementation called PAPAS (PArameter Pollution Analysis System), we conducted a large-scale analysis of more than 5,000 popular websites. Our experimental results show that about 30% of the websites that we analyzed contain vulnerable parameters and that 46.8% of the vulnerabilities we discovered (i.e., 14% of the total websites) can be exploited via HPP attacks. The fact that PAPAS was able to find vulnerabilities in many high-profile, well-known websites suggests that many developers are not aware of the HPP problem. We informed a number of major websites about the vulnerabilities we identified, and our findings were confirmed.
 Today, web attacks are increasing in frequency, sever- ity and sophistication. Existing solutions are either host- based which suffer deployment problems or middlebox ap- proaches that can only accommodate certain security pro- tection mechanisms with limited protection. In this paper, we propose four design principles for general middlebox frameworks of web protection, and apply these principles to design WebShield, which can enable various host-based se- curity mechanisms. In particular, we run all the JavaScript from remote web servers only at shadow browser instances inside the middlebox, and only run our trusted JavaScript rendering agent at client browsers. The trusted rendering agent turns browsers into a thin web terminal by recon- structing the encoded DOM of a webpage.  We implement a prototype of WebShield. Evaluation demonstrates that a general JavaScript rendering agent can render webpages precisely and be just slightly slower than direct access. We further demonstrate that our design can work well with interactive web applications such as JavaScript games. WebShield can detect attacks deeply em- bedded in dynamic HTML pages including the ones in com- plex Web 2.0 applications, and can also detect both known and unknown vulnerabilities. We further show that Web- Shield is scalable for deployment.  1  
 Leakage of private information from web applications— even when the trafﬁc is encrypted—is a major security threat to many applications that use HTTP for data deliv- ery. This paper considers the problem of inferring from en- crypted HTTP trafﬁc the web sites or web pages visited by a user. Existing browser-side approaches to this problem cannot defend against more advanced attacks, and server- side approaches usually require modiﬁcations to web enti- ties, such as browsers, servers, or web objects. In this paper, we propose a novel browser-side system, namely HTTPOS, to prevent information leaks and offer much better scalabil- ity and ﬂexibility. HTTPOS provides a comprehensive and conﬁgurable suite of trafﬁc transformation techniques for a browser to defeat trafﬁc analysis without requiring any server-side modiﬁcations. Extensive evaluation of HTTPOS on live web trafﬁc shows that it can successfully prevent the state-of-the-art attacks from inferring private information from encrypted HTTP ﬂows.  1 
 A network latency estimation scheme associates a short “position string” to each peer in a distributed system so that the latency between any two peers can be esti- mated given only their positions. Proposed applications for these schemes have included efﬁcient overlay construc- tion, compact routing, anonymous route selection, and efﬁ- cient byzantine agreement. This paper introduces Treeple, a new scheme for latency estimation, that differs from pre- vious schemes in several respects. First, Treeple is provably secure in a strong sense, rather than being designed only to resist known attacks. Second, Treeple “positions” are not based on Euclidean coordinates, but reﬂect the under- lying network topology. Third, Treeple positions are highly stable, allowing peers to retain the same position informa- tion for long periods with no maintenance. Finally, Treeple positions can be assigned to peers that do not participate directly in the scheme. We evaluate Treeple on a large in- ternet dataset (with over 200,000 measurements) and ﬁnd that on average, its latency estimates are within 26% of the true round-trip time. By comparison, Vivaldi, a popular but insecure scheme, has a median relative error of 25% on the same dataset.  1. 
 As the scope and scale of network data grows, se- curity practitioners and network operators are increas- ingly turning to automated data analysis methods to ex- tract meaningful information. Underpinning these meth- ods are distance metrics that represent the similarity be- tween two values or objects. In this paper, we argue that many of the obvious distance metrics used to mea- sure behavioral similarity among network hosts fail to capture the semantic meaning imbued by network pro- tocols. Furthermore, they also tend to ignore long-term temporal structure of the objects being measured. To ex- plore the role of these semantic and temporal character- istics, we develop a new behavioral distance metric for network hosts and compare its performance to a met- ric that ignores such information. Speciﬁcally, we pro- pose semantically meaningful metrics for common data types found within network data, show how these met- rics can be combined to treat network data as a uniﬁed metric space, and describe a temporal sequencing algo- rithm that captures long-term causal relationships. In doing so, we bring to light several challenges inherent in deﬁning behavioral metrics for network data, and put forth a new way of approaching network data analysis problems. Our proposed metric is empirically evaluated on a dataset of over 30 million network ﬂows, with re- sults that underscore the utility of a holistic approach to network data analysis.  1  
 Flow watermarks are active trafﬁc analysis techniques that help establish a causal connection between two net- work ﬂows by content-independent manipulations, e.g., al- tering packet timings. Watermarks provide a much more scalable approach for ﬂow correlation than passive trafﬁc analysis. Previous designs of scalable watermarks, how- ever, were subject to multi-ﬂow attacks. They also intro- duced delays too large to be used in most environments.  We design SWIRL, a Scalable Watermark that is Invisi- ble and Resilient to packet Losses. SWIRL is the ﬁrst water- mark that is practical to use for large-scale trafﬁc analysis. SWIRL uses a ﬂow-dependent approach to resist multi-ﬂow attacks, marking each ﬂow with a different pattern. SWIRL is robust to packet losses and network jitter, yet it intro- duces only small delays that are invisible to both benign users and determined adversaries. We analyze the perfor- mance of SWIRL both analytically and on the PlanetLab testbed, demonstrating very low error rates. We consider applications of SWIRL to stepping stone detection and link- ing anonymous communication. We also propose a novel application of watermarks to defend against congestion at- tacks on Tor.  1  
 Despite numerous improvements in the development and maintenance of software, bugs and security holes exist in to- day’s products, and malicious intrusions happen frequently. While this is a general problem, it explicitly applies to web- based services. However, Byzantine fault-tolerant (BFT) replication and proactive recovery offer a powerful com- bination to tolerate and overcome these kinds of faults, thereby enabling long-term service provision. BFT replica- tion is commonly associated with the overhead of 3f + 1 replicas to handle f faults. Using a trusted component, some previous systems were able to reduce the resource cost to 2f + 1 replicas. In general, adding support for proactive recovery further increases the resource demand. We believe this enormous resource demand is one of the key reasons why BFT replication is not commonly applied and consid- ered unsuitable for web-based services.  In this paper we present SPARE, a cloud-aware ap- proach that harnesses virtualization to reduce the resource demand of BFT replication and to provide efﬁcient support for proactive recovery. In SPARE, we focus on the main source of software bugs and intrusions; that is, the services and their associated execution environments. This approach enables us to restrict replication and request execution to only f + 1 replicas in the fault-free case while rapidly acti- vating up to f additional replicas by utilizing virtualization in case of timing violations and faults. For an instant reac- tion, we keep spare replicas that are periodically updated in a paused state. In the fault-free case, these passive repli- cas require far less resources than active replicas and aid efﬁcient proactive recovery.  1. 
 We present an efﬁcient matching protocol that can be used in many privacy-preserving biometric identiﬁcation systems in the semi-honest setting. Our most general technical con- tribution is a new backtracking protocol that uses the by- product of evaluating a garbled circuit to enable efﬁcient oblivious information retrieval. We also present a more ef- ﬁcient protocol for computing the Euclidean distances of vectors, and optimized circuits for ﬁnding the closest match between a point held by one party and a set of points held by another. We evaluate our protocols by implementing a practical privacy-preserving ﬁngerprint matching system.  1  
 We report the results of a usability study of Bumpy, a system that enables a user to provide secret inputs to re- mote webservers without trusting the computer on which she types those inputs. Achieving this somewhat paradoxi- cal property via Bumpy requires extra diligence from users, raising questions as to whether it is a viable protection for the average user. We evaluate the originally proposed Bumpy design and several new alternatives in a user study involving 85 participants, each of whom utilized one of these designs (or a control design) for roughly four months to protect her password entries to a university course web page. Beyond assessing the usability of Bumpy designs, our study offers insights for designing security-relevant inter- faces and training users to successfully utilize them.  1  
 The counterfeiting of pharmaceutics or luxury objects is a major threat to supply chains today. As different facili- ties of a supply chain are distributed and difﬁcult to mon- itor, malicious adversaries can inject fake objects into the supply chain. This paper presents TRACKER, a protocol for object genuineness veriﬁcation in RFID-based supply chains. More precisely, TRACKER allows to securely iden- tify which (legitimate) path an object/tag has taken through a supply chain. TRACKER provides privacy: an adversary can neither learn details about an object’s path, nor can it trace and link objects in the supply chain. TRACKER’s security and privacy is based on an extension of polyno- mial signature techniques for run-time fault detection using homomorphic encryption. Contrary to related work, RFID tags in this paper are not required to perform any computa- tion, but only feature a few bytes of storage such as ordinary EPC Class 1 Gen 2 tags.  1. 
 This allows third-parties to create detailed proﬁles of users’ application preferences and usage patterns.  With the introduction of Apple’s iOS and Google’s An- droid operating systems, the sales of smartphones have ex- ploded. These smartphones have become powerful devices that are basically miniature versions of personal comput- ers. However, the growing popularity and sophistication of smartphones have also increased concerns about the pri- vacy of users who operate these devices. These concerns have been exacerbated by the fact that it has become in- creasingly easy for users to install and execute third-party applications. To protect its users from malicious applica- tions, Apple has introduced a vetting process. This vet- ting process should ensure that all applications conform to Apple’s (privacy) rules before they can be offered via the App Store. Unfortunately, this vetting process is not well- documented, and there have been cases where malicious applications had to be removed from the App Store after user complaints.  In this paper, we study the privacy threats that applica- tions, written for Apple’s iOS, pose to users. To this end, we present a novel approach and a tool, PiOS, that allow us to analyze programs for possible leaks of sensitive in- formation from a mobile device to third parties. PiOS uses static analysis to detect data ﬂows in Mach-0 binaries, com- piled from Objective-C code. This is a challenging task due to the way in which Objective-C method calls are imple- mented. We have analyzed more than 1,400 iPhone appli- cations. Our experiments show that, with the exception of a few bad apples, most applications respect personal identiﬁ- able information stored on user’s devices. This is even true for applications that are hosted on an unofﬁcial repository (Cydia) and that only run on jailbroken phones. However, we found that more than half of the applications surrepti- tiously leak the unique ID of the device they are running on.  1 
 With the introduction of Apple’s iOS and Google’s Android operating systems, the sales of smartphones have exploded. These smartphones have become powerful devices that are basically miniature versions of personal computers. However, the growing popularity and sophistication of smartphones have also increased concerns about the privacy of users who operate these devices. These concerns have been exacerbated by the fact that it has become increasingly easy for users to install and execute third-party applications. To protect its users from malicious applications, Apple has introduced a vetting process. This vetting process should ensure that all applications conform to Apple’s (privacy) rules before they can be offered via the App Store. Unfortunately, this vetting process is not welldocumented, and there have been cases where malicious applications had to be removed from the App Store after user complaints. In this paper, we study the privacy threats that applications, written for Apple’s iOS, pose to users. To this end, we present a novel approach and a tool, PiOS, that allow us to analyze programs for possible leaks of sensitive information from a mobile device to third parties. PiOS uses static analysis to detect data flows in Mach-0 binaries, compiled from Objective-C code. This is a challenging task due to the way in which Objective-C method calls are implemented. We have analyzed more than 1,400 iPhone applications. Our experiments show that, with the exception of a few bad apples, most applications respect personal identifiable information stored on user’s devices. This is even true for applications that are hosted on an unofficial repository (Cydia) and that only run on jailbroken phones. However, we found that more than half of the applications surreptitiously leak the unique ID of the device they are running on.
 We consider how an untrusted data aggregator can learn desired statistics over multiple participants’ data, without compromising each individual’s privacy. We propose a construction that allows a group of partici- pants to periodically upload encrypted values to a data aggregator, such that the aggregator is able to compute the sum of all participants’ values in every time period, but is unable to learn anything else. We achieve strong privacy guarantees using two main techniques. First, we show how to utilize applied cryptographic techniques to allow the aggregator to decrypt the sum from multiple ciphertexts encrypted under different user keys. Second, we describe a distributed data randomization procedure that guarantees the differential privacy of the outcome statistic, even when a subset of participants might be compromised.  1  
