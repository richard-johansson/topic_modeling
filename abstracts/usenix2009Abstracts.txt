 Computer keyboards are often used to transmit conﬁden- tial data such as passwords. Since they contain elec- tronic components, keyboards eventually emit electro- magnetic waves. These emanations could reveal sensi- tive information such as keystrokes. The technique gen- erally used to detect compromising emanations is based on a wide-band receiver, tuned on a speciﬁc frequency. However, this method may not be optimal since a sig- niﬁcant amount of information is lost during the signal acquisition. Our approach is to acquire the raw signal directly from the antenna and to process the entire cap- tured electromagnetic spectrum. Thanks to this method, we detected four different kinds of compromising elec- tromagnetic emanations generated by wired and wireless keyboards. These emissions lead to a full or a partial recovery of the keystrokes. We implemented these side- channel attacks and our best practical attack fully recov- ered 95% of the keystrokes of a PS/2 keyboard at a dis- tance up to 20 meters, even through walls. We tested 12 different keyboard models bought between 2001 and 2008 (PS/2, USB, wireless and laptop). They are all vul- nerable to at least one of the four attacks. We conclude that most of modern computer keyboards generate com- promising emanations (mainly because of the manufac- turer cost pressures in the design). Hence, they are not safe to transmit conﬁdential information.  puters, to do e-banking money transfer, etc. A weakness in these hardware devices will jeopardize the security of any password-based authentication system.  Compromising electromagnetic emanation problems appeared already at the end of the 19th century. Be- cause of the extensive use of telephones, wire networks became extremely dense. People could sometimes hear other conversations on their phone line due to undesired coupling between parallel wires. This unattended phe- nomenon, called crosstalk, may be easily canceled by twisting the cables.  A description of some early exploitations of compro- mising emanations has been recently declassiﬁed by the National Security Agency [26]. During World War II, the American Army used teletypewriter communications encrypted with Bell 131-B2 mixing devices. In a Bell laboratory, a researcher noticed, quite by accident, that each time the machine stepped, a spike appeared on an oscilloscope in a distant part of the lab. To prove the vul- nerability of the device, Bell engineers captured the com- promising emanations emitted by a Bell 131-B2, placed in a building across the street and about 25 meters away. They were able to recover 75% of the plaintext.  During the Vietnam war, a sensor called Black Crow carried aboard C-130 gunships was able to detect the electromagnetic emanations produced by the ignition system of trucks on the Ho Chi Minh trail, from a dis- tance up to 10 miles [25, 11].  1 
 A multi-user system usually involves a large amount of information shared among its users. The security impli- cations of such information can never be underestimated. In this paper, we present a new attack that allows a ma- licious user to eavesdrop on other users’ keystrokes us- ing such information. Our attack takes advantage of the stack information of a process disclosed by its virtual ﬁle within procfs, the process ﬁle system supported by Linux. We show that on a multi-core system, the ESP of a process when it is making system calls can be ef- fectively sampled by a “shadow” program that continu- ously reads the public statistical information of the pro- cess. Such a sampling is shown to be reliable even in the presence of multiple users, when the system is under a realistic workload. From the ESP content, a keystroke event can be identiﬁed if they trigger system calls. As a result, we can accurately determine inter-keystroke tim- ings and launch a timing attack to infer the characters the victim entered.  We developed techniques for automatically analyzing an application’s binary executable to extract the ESP pat- tern that ﬁngerprints a keystroke event. The occurrences of such a pattern are identiﬁed from an ESP trace the shadow program records from the application’s runtime to calculate timings. These timings are further analyzed using a Hidden Markov Model and other public informa- tion related to the victim on a multi-user system. Our experimental study demonstrates that our attack greatly facilitates password cracking and also works very well on recognizing English words.  1 
 In 2005, Murdoch and Danezis demonstrated the ﬁrst practical congestion attack against a deployed anonymity network. They could identify which relays were on a target Tor user’s path by building paths one at a time through every Tor relay and introducing congestion. However, the original attack was performed on only 13 Tor relays on the nascent and lightly loaded Tor network. We show that the attack from their paper is no longer practical on today’s 1500-relay heavily loaded Tor net- work. The attack doesn’t scale because a) the attacker needs a tremendous amount of bandwidth to measure enough relays during the attack window, and b) there are too many false positives now that many other users are adding congestion at the same time as the attacks.  We then strengthen the original congestion attack by combining it with a novel bandwidth ampliﬁcation at- tack based on a ﬂaw in the Tor design that lets us build long circuits that loop back on themselves. We show that this new combination attack is practical and effective by demonstrating a working attack on today’s deployed Tor network. By coming up with a model to better under- stand Tor’s routing behavior under congestion, we fur- ther provide a statistical analysis characterizing how ef- fective our attack is in each case.  1  
Attacks that exploit out-of-bounds errors in C and C++ programs are still prevalent despite many years of re- search on bounds checking. Previous backwards compat- ible bounds checking techniques, which can be applied to unmodiﬁed C and C++ programs, maintain a data struc- ture with the bounds for each allocated object and per- form lookups in this data structure to check if pointers remain within bounds. This data structure can grow large and the lookups are expensive.  In this paper we present a backwards compatible bounds checking technique that substantially reduces perfor- mance overhead. The key insight is to constrain the sizes of allocated memory regions and their alignment to en- able efﬁcient bounds lookups and hence efﬁcient bounds checks at runtime. Our technique has low overhead in practice—only 8% throughput decrease for Apache— and is more than two times faster than the fastest pre- vious technique and about ﬁve times faster—using less memory—than recording object bounds using a splay tree.  1 
 Recently, integer bugs, including integer overﬂow, width conversion, and signed/unsigned conversion errors, have risen to become a common root cause for serious security vulnerabilities. We introduce new methods for discover- ing integer bugs using dynamic test generation on x86 binaries, and we describe key design choices in efﬁcient symbolic execution of such programs. We implemented our methods in a prototype tool SmartFuzz, which we use to analyze Linux x86 binary executables. We also created a reporting service, metafuzz.com, to aid in triaging and reporting bugs found by SmartFuzz and the black-box fuzz testing tool zzuf. We report on experi- ments applying these tools to a range of software appli- cations, including the mplayer media player, the exiv2 image metadata library, and ImageMagick convert. We also report on our experience using SmartFuzz, zzuf, and metafuzz.com to perform testing at scale with the Amazon Elastic Compute Cloud (EC2). To date, the metafuzz.com site has recorded more than 2, 614 test runs, comprising 2, 361, 595 test cases. Our experiments found approximately 77 total distinct bugs in 864 com- pute hours, costing us an average of $2.24 per bug at cur- rent EC2 rates. We quantify the overlap in bugs found by the two tools, and we show that SmartFuzz ﬁnds bugs missed by zzuf, including one program where Smart- Fuzz ﬁnds bugs but zzuf does not.  1 
 Systems that enforce memory safety for today’s oper- ating system kernels and other system software do not account for the behavior of low-level software/hardware interactions such as memory-mapped I/O, MMU con(cid:2)g- uration, and context switching. Bugs in such low-level interactions can lead to violations of the memory safety guarantees provided by a safe execution environment and can lead to exploitable vulnerabilities in system software. In this work, we present a set of program analysis and run-time instrumentation techniques that ensure that er- rors in these low-level operations do not violate the as- sumptions made by a safety checking system. Our de- sign introduces a small set of abstractions and interfaces for manipulating processor state, kernel stacks, memory mapped I/O objects, MMU mappings, and self modify- ing code to achieve this goal, without moving resource allocation and management decisions out of the kernel. We have added these techniques to a compiler-based vir- tual machine called Secure Virtual Architecture (SVA), to which the standard Linux kernel has been ported previ- ously. Our design changes to SVA required only an addi- tional 100 lines of code to be changed in this kernel. Our experimental results show that our techniques prevent re- ported memory safety violations due to low-level Linux operations and that these violations are not prevented by SVA without our techniques. Moreover, the new tech- niques in this paper introduce very little overhead over and above the existing overheads of SVA. Taken together, these results indicate that it is clearly worthwhile to add these techniques to an existing memory safety system.  1 
 Users and network administrators need ways to ﬁlter email messages based primarily on the reputation of the sender. Unfortunately, conventional mechanisms for sender reputation—notably, IP blacklists—are cumber- some to maintain and evadable. This paper investigates ways to infer the reputation of an email sender based solely on network-level features, without looking at the contents of a message. First, we study ﬁrst-order prop- erties of network-level features that may help distinguish spammers from legitimate senders. We examine features that can be ascertained without ever looking at a packet’s contents, such as the distance in IP space to other email senders or the geographic distance between sender and receiver. We derive features that are lightweight, since they do not require seeing a large amount of email from a single IP address and can be gleaned without looking at an email’s contents—many such features are appar- ent from even a single packet. Second, we incorporate these features into a classiﬁcation algorithm and evalu- ate the classiﬁer’s ability to automatically classify email senders as spammers or legitimate senders. We build an automated reputation engine, SNARE, based on these features using labeled data from a deployed commercial spam-ﬁltering system. We demonstrate that SNARE can achieve comparable accuracy to existing static IP black- lists: about a 70% detection rate for less than a 0.3% false positive rate. Third, we show how SNARE can be inte- grated into existing blacklists, essentially as a ﬁrst-pass ﬁlter.  1 
 Preﬁx hijacking is one of the top known threats on to- day’s Internet. A number of measurement based so- lutions have been proposed to detect preﬁx hijacking events. In this paper we take these solutions one step fur- ther by addressing the problem of locating the attacker in each of the detected hijacking event. Being able to locate the attacker is critical for conducting necessary mitiga- tion mechanisms at the earliest possible time to limit the impact of the attack, successfully stopping the attack and restoring the service.  We propose a robust scheme named LOCK, for LO- Cating the preﬁx hijacKer ASes based on distributed In- ternet measurements. LOCK locates each attacker AS by actively monitoring paths (either in the control-plane or in the data-plane) to the victim preﬁx from a small number of carefully selected monitors distributed on the Internet. Moreover, LOCK is robust against various countermeasures that the hijackers may employ. This is achieved by taking advantage of two observations: that the hijacker cannot manipulate AS path before the path reaches the hijacker, and that the paths to victim preﬁx “converge” around the hijacker AS. We have deployed LOCK on a number of PlanetLab nodes and conducted several large scale measurements and experiments to evaluate the performance. Our results show that LOCK is able to pinpoint the preﬁx hijacker AS with an accu- racy up to 94.3%.  1  
 The advent of Web 2.0 has lead to the proliferation of client-side code that is typically written in JavaScript. This code is often combined — or mashed-up — with other code and content from disparate, mutually untrust- ing parties, leading to undesirable security and reliability consequences.  This paper proposes GATEKEEPER, a mostly static ap- proach for soundly enforcing security and reliability poli- cies for JavaScript programs. GATEKEEPER is a highly extensible system with a rich, expressive policy language, allowing the hosting site administrator to formulate their policies as succinct Datalog queries.  The primary application of GATEKEEPER this paper ex- plores is in reasoning about JavaScript widgets such as those hosted by widget portals Live.com and Google/IG. Widgets submitted to these sites can be either malicious or just buggy and poorly written, and the hosting site has the authority to reject the submission of widgets that do not meet the site’s security policies.  To show the practicality of our approach, we de- scribe nine representative security and reliability policies. Statically checking these policies results in 1,341 veriﬁed warnings in 684 widgets, no false negatives, due to the soundness of our analysis, and false positives affecting only two widgets.  1  
 Heap spraying is a security attack that increases the ex- ploitability of memory corruption errors in type-unsafe applications. In a heap-spraying attack, an attacker co- erces an application to allocate many objects containing malicious code in the heap, increasing the success rate of an exploit that jumps to a location within the heap. Be- cause heap layout randomization necessitates new forms of attack, spraying has been used in many recent security exploits. Spraying is especially effective in web browsers, where the attacker can easily allocate the malicious ob- jects using JavaScript embedded in a web page. In this paper, we describe NOZZLE, a runtime heap-spraying de- tector. NOZZLE examines individual objects in the heap, interpreting them as code and performing a static analysis on that code to detect malicious intent. To reduce false positives, we aggregate measurements across all heap ob- jects and deﬁne a global heap health metric.  We measure the effectiveness of NOZZLE by demon- strating that it successfully detects 12 published and 2,000 synthetically generated heap-spraying exploits. We also show that even with a detection threshold set six times lower than is required to detect published malicious attacks, NOZZLE reports no false positives when run over 150 popular Internet sites. Using sampling and con- current scanning to reduce overhead, we show that the performance overhead of NOZZLE is less than 7% on av- erage. While NOZZLE currently targets heap-based spray- ing attacks, its techniques can be applied to any attack that attempts to ﬁll the address space with malicious code ob- jects (e.g., stack spraying [42]).  1 
 We identify a class of Web browser implementation vulnerabilities, cross-origin JavaScript capability leaks, which occur when the browser leaks a JavaScript pointer from one security origin to another. We devise an algo- rithm for detecting these vulnerabilities by monitoring the “points-to” relation of the JavaScript heap. Our algo- rithm ﬁnds a number of new vulnerabilities in the open- source WebKit browser engine used by Safari. We pro- pose an approach to mitigate this class of vulnerabilities by adding access control checks to browser JavaScript engines. These access control checks are backwards- compatible because they do not alter semantics of the Web platform. Through an application of the inline cache, we implement these checks with an overhead of 1–2% on industry-standard benchmarks.  
In this work we perform the ﬁrst comprehensive study of physical-layer identiﬁcation of RFID transponders. We propose several techniques for the extraction of RFID physical-layer ﬁngerprints. We show that RFID transponders can be accurately identiﬁed in a controlled environment based on stable ﬁngerprints corresponding to their physical-layer properties. We tested our tech- niques on a set of 50 RFID smart cards of the same manufacturer and type, and we show that these tech- niques enable the identiﬁcation of individual transpon- ders with an Equal Error Rate of 2.43% (single run) and 4.38% (two runs). We further applied our techniques to a smaller set of electronic passports, where we obtained a similar identiﬁcation accuracy. Our results indicate that physical-layer identiﬁcation of RFID transponders can be practical and thus has a potential to be used in a number of applications including product and document counterfeiting detection.  1  
 Passive RFID tags harvest their operating energy from an interrogating reader, but constant energy shortfalls severely limit their computational and storage capabili- ties. We propose Cryptographic Computational Contin- uation Passing (CCCP), a mechanism that ampliﬁes pro- grammable passive RFID tags’ capabilities by exploiting an often overlooked, plentiful resource: low-power radio communication. While radio communication is more en- ergy intensive than ﬂash memory writes in many embed- ded devices, we show that the reverse is true for passive RFID tags. A tag can use CCCP to checkpoint its com- putational state to an untrusted reader using less energy than an equivalent ﬂash write, thereby allowing it to de- vote a greater share of its energy to computation.  Security is the major challenge in such remote check- pointing. Using scant and ﬂeeting energy, a tag must enforce conﬁdentiality, authenticity, integrity, and data freshness while communicating with potentially untrust- worthy infrastructure. Our contribution synthesizes well- known cryptographic and low-power techniques with a novel ﬂash memory storage strategy, resulting in a secure remote storage facility for an emerging class of devices. Our evaluation of CCCP consists of energy measure- ments of a prototype implementation on the batteryless, MSP430-based WISP platform. Our experiments show that—despite cryptographic overhead—remote check- pointing consumes less energy than checkpointing to ﬂash for data sizes above roughly 64 bytes. CCCP en- ables secure and ﬂexible remote storage that would oth- erwise outstrip batteryless RFID tags’ resources.  1 
 Jamming-resistant broadcast communication is crucial for safety-critical applications such as emergency alert broadcasts or the dissemination of navigation signals in adversarial settings. These applications share the need for guaranteed authenticity and availability of messages which are broadcasted by base stations to a large and unknown number of (potentially untrusted) receivers. Common techniques to counter jamming attacks such as Direct-Sequence Spread Spectrum (DSSS) and Fre- quency Hopping are based on secrets that need to be shared between the sender and the receivers before the start of the communication. However, broadcast anti- jamming communication that relies on either secret pair- wise or group keys is likely to be subject to scalabil- ity and key-setup problems or provides weak jamming- resistance, respectively. In this work, we therefore pro- pose a solution called Uncoordinated DSSS (UDSSS) that enables spread-spectrum anti-jamming broadcast communication without the requirement of shared se- crets. It is applicable to broadcast scenarios in which receivers hold an authentic public key of the sender but do not share a secret key with it. UDSSS can handle an unlimited amount of receivers while being secure against malicious receivers. We analyze the security and latency of UDSSS and complete our work with an experimental evaluation on a prototype implementation.  1  
Social networking websites have recently evolved from being service providers to platforms for running third party applications. Users have typically trusted the so- cial networking sites with personal data, and assume that their privacy preferences are correctly enforced. However, they are now being asked to trust each third-party applica- tion they use in a similar manner. This has left the users’ private information vulnerable to accidental or malicious leaks by these applications.  In this work, we present a novel framework for build- ing privacy-preserving social networking applications that retains the functionality offered by the current social net- works. We use information ﬂow models to control what untrusted applications can do with the information they receive. We show the viability of our design by means of a platform prototype. The usability of the platform is further evaluated by developing sample applications using the platform APIs. We also discuss both security and non- security challenges in designing and implementing such a framework.  1 
 This paper presents Nemesis, a novel methodology for mitigating authentication bypass and access control vul- nerabilities in existing web applications. Authentication attacks occur when a web application authenticates users unsafely, granting access to web clients that lack the ap- propriate credentials. Access control attacks occur when an access control check in the web application is incor- rect or missing, allowing users unauthorized access to privileged resources such as databases and ﬁles. Such attacks are becoming increasingly common, and have oc- curred in many high-proﬁle applications, such as IIS [10] and WordPress [31], as well as 14% of surveyed web sites [30]. Nevertheless, none of the currently available tools can fully mitigate these attacks.  Nemesis automatically determines when an application safely and correctly authenticates users, by using Dy- namic Information Flow Tracking (DIFT) techniques to track the ﬂow of user credentials through the application’s language runtime. Nemesis combines authentication in- formation with programmer-supplied access control rules on ﬁles and database entries to automatically ensure that only properly authenticated users are granted access to any privileged resources or data. A study of seven pop- ular web applications demonstrates that a prototype of Nemesis is effective at mitigating attacks, requires little programmer effort, and imposes minimal runtime over- head. Finally, we show that Nemesis can also improve the precision of existing security tools, such as DIFT analy- ses for SQL injection prevention, by providing runtime information about user authentication.  1  
Security vulnerabilities continue to plague web appli- cations, allowing attackers to access sensitive data and co-opt legitimate web sites as a hosting ground for mal- ware. Accordingly, researchers have focused on various approaches to detecting and preventing common classes of security vulnerabilities in web applications, includ- ing anomaly-based detection mechanisms, static and dy- namic analyses of server-side web application code, and client-side security policy enforcement.  This paper presents a different approach to web appli- cation security. In this work, we present a web appli- cation framework that leverages existing work on strong type systems to statically enforce a separation between the structure and content of both web documents and database queries generated by a web application, and show how this approach can automatically prevent the introduction of both server-side cross-site scripting and SQL injection vulnerabilities. We present an evaluation of the framework, and demonstrate both the coverage and correctness of our sanitization functions. Finally, exper- imental results suggest that web applications developed using this framework perform competitively with appli- cations developed using traditional frameworks.  Keywords: Web applications, strongly typed languages, functional languages, cross-site scripting, SQL in- jection.  1  
 and  legal  technical  landscape  presents Today’s formidable challenges to personal data privacy. First, our increasing reliance on Web services causes personal data to be cached, copied, and archived by third parties, often without our knowledge or control. Second, the disclosure of private data has become commonplace due to carelessness, theft, or legal actions.  Our research seeks to protect the privacy of past, archived data — such as copies of emails maintained by an email provider — against accidental, malicious, and legal attacks. Speciﬁcally, we wish to ensure that all copies of certain data become unreadable after a user- speciﬁed time, without any speciﬁc action on the part of a user, and even if an attacker obtains both a cached copy of that data and the user’s cryptographic keys and pass- words.  This paper presents Vanish, a system that meets this challenge through a novel integration of cryptographic techniques with global-scale, P2P, distributed hash ta- bles (DHTs). We implemented a proof-of-concept Van- ish prototype to use both the million-plus-node Vuze Bit- Torrent DHT and the restricted-membership OpenDHT. We evaluate experimentally and analytically the func- tionality, security, and performance properties of Vanish, demonstrating that it is practical to use and meets the privacy-preserving goals described above. We also de- scribe two applications that we prototyped on Vanish: a Firefox plugin for Gmail and other Web sites and a Van- ishing File application.  1  
 Many real-world applications wish to collect tamper- evident logs for forensic purposes. This paper considers the case of an untrusted logger, serving a number of clients who wish to store their events in the log, and kept honest by a number of auditors who will challenge the logger to prove its correct behavior. We propose semantics of tamper-evident logs in terms of this auditing process. The logger must be able to prove that individual logged events are still present, and that the log, as seen now, is consistent with how it was seen in the past. To accomplish this efﬁciently, we describe a tree-based data structure that can generate such proofs with logarithmic size and space, improving over previous linear con- structions. Where a classic hash chain might require an 800 MB trace to prove that a randomly chosen event is in a log with 80 million events, our prototype returns a 3 KB proof with the same semantics. We also present a ﬂexible mechanism for the log server to present authenticated and tamper-evident search results for all events matching a predicate. This can allow large-scale log servers to selectively delete old events, in an agreed-upon fashion, while generating efﬁcient proofs that no inappropriate events were deleted. We describe a prototype imple- mentation and measure its performance on an 80 million event syslog trace at 1,750 events per second using a single CPU core. Performance improves to 10,500 events per second if cryptographic signatures are ofﬂoaded, corresponding to 1.1 TB of logging throughput per week.  1 
A variety of location-based vehicular services are cur- rently being woven into the national transportation in- frastructure in many countries. These include usage- or congestion-based road pricing, trafﬁc law enforcement, trafﬁc monitoring, “pay-as-you-go” insurance, and vehi- cle safety systems. Although such applications promise clear beneﬁts, there are signiﬁcant potential violations of the location privacy of drivers under standard imple- mentations (i.e., GPS monitoring of cars as they drive, surveillance cameras, and toll transponders).  In this paper, we develop and evaluate VPriv, a sys- tem that can be used by several such applications with- out violating the location privacy of drivers. The start- ing point is the observation that in many applications, some centralized server needs to compute a function of a user’s path—a list of time-position tuples. VPriv pro- vides two components: 1) the ﬁrst practical protocol to compute path functions for various kinds of tolling, speed and delay estimation, and insurance calculations in a way that does not reveal anything more than the re- sult of the function to the server, and 2) an out-of-band enforcement mechanism using random spot checks that allows the server and application to handle misbehav- ing users. Our implementation and experimental eval- uation of VPriv shows that a modest infrastructure of a few multi-core PCs can easily serve 1 million cars. Us- ing analysis and simulation based on real vehicular data collected over one year from the CarTel project’s testbed of 27 taxis running in the Boston area, we demonstrate that VPriv is resistant to a range of possible attacks.  1  
Malware is one of the most serious security threats on the Internet today. In fact, most Internet problems such as spam e-mails and denial of service attacks have mal- ware as their underlying cause. That is, computers that are compromised with malware are often networked to- gether to form botnets, and many attacks are launched using these malicious, attacker-controlled networks.  With the increasing signiﬁcance of malware in Inter- net attacks, much research has concentrated on develop- ing techniques to collect, study, and mitigate malicious code. Without doubt, it is important to collect and study malware found on the Internet. However, it is even more important to develop mitigation and detection techniques based on the insights gained from the analysis work. Unfortunately, current host-based detection approaches (i.e., anti-virus software) suffer from ineffective detec- tion models. These models concentrate on the features of a speciﬁc malware instance, and are often easily evad- able by obfuscation or polymorphism. Also, detectors that check for the presence of a sequence of system calls exhibited by a malware instance are often evadable by system call reordering. In order to address the shortcom- ings of ineffective models, several dynamic detection ap- proaches have been proposed that aim to identify the be- havior exhibited by a malware family. Although promis- ing, these approaches are unfortunately too slow to be used as real-time detectors on the end host, and they of- ten require cumbersome virtual machine technology.  In this paper, we propose a novel malware detection approach that is both effective and efﬁcient, and thus, can be used to replace or complement traditional anti-virus software at the end host. Our approach ﬁrst analyzes a malware program in a controlled environment to build a model that characterizes its behavior. Such models de- scribe the information ﬂows between the system calls es- sential to the malware’s mission, and therefore, cannot be easily evaded by simple obfuscation or polymorphic techniques. Then, we extract the program slices respon-  sible for such information ﬂows. For detection, we exe- cute these slices to match our models against the runtime behavior of an unknown program. Our experiments show that our approach can effectively detect running mali- cious code on an end user’s host with a small overhead.  1 
   Protecting  confidential information is a major concern for organizations and individuals alike, who stand to suffer  huge losses if private data falls into the wrong hands. One of the primary threats to confidentiality is malicious soft- ware on personal computers, which is estimated to already reside on 100 to 150 million machines. Current security  controls, such as firewalls, anti-virus software, and intrusion detection systems, are inadequate at preventing malware  infection.  This  paper  introduces  Storages  Capsules,  a  new  approach  for  protecting  confidential files on a personal  computer.  Storage  Capsules  are  encrypted  file containers that allow a compromised machine to securely view and  edit sensitive files without malware being able to steal confidential data. The system achieves this goal by taking a  checkpoint of the current system state and disabling device output before allowing access a Storage Capsule. Writes  to the Storage Capsule are then sent to a trusted module. When the user is done editing files in the Storage Capsule,  the system is restored to its original state and device output resumes normally. Finally, the trusted module declassi- fies the Storage Capsule by re-encrypting its contents, and exports it for storage in a low-integrity environment. This  work  presents  the  design,  implementation,  and  evaluation  of  Storage  Capsules,  with  a  focus  on  exploring  covert  channels.   1.  
 Protecting the kernel of an operating system against at- tacks, especially injection of malicious code, is an impor- tant factor for implementing secure operating systems. Several kernel integrity protection mechanism were pro- posed recently that all have a particular shortcoming: They cannot protect against attacks in which the attacker re-uses existing code within the kernel to perform mali- cious computations. In this paper, we present the design and implementation of a system that fully automates the process of constructing instruction sequences that can be used by an attacker for malicious computations. We eval- uate the system on different commodity operating sys- tems and show the portability and universality of our approach. Finally, we describe the implementation of a practical attack that can bypass existing kernel integrity protection mechanisms.  1  
 Web users are shown an invalid certiﬁcate warning when their browser cannot validate the identity of the websites they are visiting. While these warn- ings often appear in benign situations, they can also signal a man-in-the-middle attack. We conducted a survey of over 400 Internet users to examine their reactions to and understanding of current SSL warn- ings. We then designed two new warnings using warn- ings science principles and lessons learned from the survey. We evaluated warnings used in three pop- ular web browsers and our two warnings in a 100- participant, between-subjects laboratory study. Our warnings performed signiﬁcantly better than exist- ing warnings, but far too many participants exhibited dangerous behavior in all warning conditions. Our re- sults suggest that, while warnings can be improved, a better approach may be to minimize the use of SSL warnings altogether by blocking users from making unsafe connections and eliminating warnings in be- nign situations.  1  
Original web browsers were applications designed to view static web content. As web sites evolved into dy- namic web applications that compose content from mul- tiple web sites, browsers have become multi-principal operating environments with resources shared among mutually distrusting web site principals. Nevertheless, no existing browsers, including new architectures like IE 8, Google Chrome, and OP, have a multi-principal oper- ating system construction that gives a browser-based OS the exclusive control to manage the protection of all sys- tem resources among web site principals.  In this paper, we introduce Gazelle, a secure web browser constructed as a multi-principal OS. Gazelle’s browser kernel is an operating system that exclusively manages resource protection and sharing across web site principals. This construction exposes intricate design is- sues that no previous work has identiﬁed, such as cross- protection-domain display and events protection. We elaborate on these issues and provide comprehensive so- lutions.  Our prototype implementation and evaluation expe- rience indicates that it is realistic to turn an existing browser into a multi-principal OS that yields signiﬁ- cantly stronger security and robustness with acceptable performance.  1 
