 Everyday network interactions require users to give out their email address, yet no guarantees can be made about how this address will be used. Sometimes the address is given to a human (e.g., on a business card), but many times it is entered in a web form as part of a web trans- action. Unfortunately, that email address frequently ﬁnds itself in spammers’ lists, never to be removed again. We propose the concept of the Single-Purpose Address (SPA); SPAs are generated by a program, and then cut-and- pasted into the web page (or other application) requesting an email address. In its more general form an SPA en- codes a security policy that describes the acceptable use of the address; since senders cannot be trusted to abide by it, this policy is enforced by the receiver, who generated the policy in the ﬁrst place. SPAs are cryptographically protected to shield them from tampering. Since SPAs are not meant to be typed by humans, but rather processed by computer only, they do not have to be short, memorable, or even pronounceable. We present ways to construct such addresses, and we show the implementation of an opti- mized case.  1. 
 A resource may be abused if its users incur little or no cost. For example, e-mail abuse is rampant because send- ing an e-mail has negligible cost for the sender. It has been suggested that such abuse may be discouraged by in- troducing an artiﬁcial cost in the form of a moderately ex- pensive computation. Thus, the sender of an e-mail might be required to pay by computing for a few seconds before the e-mail is accepted. Unfortunately, because of sharp disparities across computer systems, this approach may be ineffective against malicious users with high-end sys- tems, prohibitively slow for legitimate users with low-end systems, or both. Starting from this observation, we re- search moderately hard functions that most recent systems will evaluate at about the same speed. For this purpose, we rely on memory-bound computations. We describe and analyze a family of moderately hard, memory-bound functions, and we explain how to use them for protecting against abuses.  1. 
 This paper presents the design and analysis of a multi- layer protection scheme against denial-of-service (DoS) attacks in IP telephony enabled enterprise networks. While there are many types of DoS attacks, we focus on ﬂood-based attacks using application layer and transport layer signaling messages in IP telephony. We design sen- sors to detect and control these types attacks and consider different location of these sensors in the enterprise net- work. The algorithm for detecting these attacks is based on the well established non-parametric cumulative sum method. The response to the attack uses standard pro- tocol features of IP telephony to control the number of incoming application and transport layer setup requests. We consider different recovery algorithms and compare their performance using our emulation toolkit. Our re- sults show that the detection algorithm can quickly detect both transport and application layer attacks and is robust against various types of attacks. We also show that with proper choice of sensor parameters, the detection algo- rithm is effective over a wide range of call volumes.  1. 
As our economy and critical infrastructure increasingly rely on the Internet, securing routing protocols becomes of critical impor- tance. In this paper, we present four new mechanisms as tools for securing distance vector and path vector routing protocols. For securing distance vector protocols, our hash tree chain mecha- nism forces a router to increase the distance (metric) when for- warding a routing table entry. To provide authentication of a re- ceived routing update in bounded time, we present a new mecha- nism, similar to hash chains, that we call tree-authenticated one- way chains. For cases in which the maximum metric is large, we present skiplists, which provides more ef(cid:2)cient initial computa- tion cost and more ef(cid:2)cient element veri(cid:2)cation; this mechanism is based on a new cryptographic mechanism, called MW-chains, which we also present. For securing path vector protocols, our cu- mulative authentication mechanism authenticates the list of routers on the path in a routing update, preventing removal or reordering of the router addresses in the list; the mechanism uses only a sin- gle authenticator in the routing update rather than one per router address. We also present a simple mechanism to securely switch one-way chains, by authenticating the next one-way chain using the previous one. These mechanisms are all based on ef(cid:2)cient symmetric cryptographic techniques and can be used as building blocks for securing routing protocols.  1.  
 BGP is essential to the operation of the Internet, but is vulnerable to both accidental failures and malicious at- tacks. We propose a new protocol that works in concert with BGP, which Autonomous Systems will use to help de- tect and mitigate accidentally or maliciously introduced faulty routing information. The protocol differs from pre- vious efforts at securing BGP in that it is receiver-driven, meaning that there is a mechanism for recipients of BGP UPDATE messages to corroborate the information they receive and to provide feedback. We argue that our new protocol can be adopted incrementally, and we show that there is incentive for network operators to do so. We also describe our prototype implementation.  1. 
 ver  d fr  ent tr  ed. In the curr  ,  when  the  curr  verloading has led to se  oblems,  including  the  so  called  addr    ds mobile end in mobile networking is towar The curr WLAN hosts  that  have  multiple  network  interfaces,  e   .,  .g and  GPRS.  Howe - hitec c ent  Internet  ar e  was  originally  designed,  neither  mobility  nor  multi- tur   e an IP homing wer s top epr addr - ess r al secu ver olo - gical location.  ship rity  pr   ess  owner - oblem,  making  IP  mobility  and  multi-homing  unneces pr sarily har  e consider esents both a host’ This o  hitectur c ent ar s identity and the host’  om the security point of vie In  this  paper  we  show  how  the  Host  Identity  P  ayload   , can be used to simulta - - ac elated to end-host multi-homing and end- - w  crypto otocol  layer  between  network xed  binding  between - h is especially suita xisting trust r - e eport  our  early  (HIP), being discussed at the IETF neously solve the security pr tical pr host  mobility gr and  tr s,  br ansport  layer eaking  the  ﬁ identities and locations.  oac The appr e no pr e open networks, wher ble for lar g lationships  can  be  assumed.  e  also  r W implementation e  oblems, and many of the pr  aphic  name  space  and  pr  oduces  a  ne  xperiences.  .  Basically  ,  HIP  intr  oblems, r  e-e  . w          1.  
 Security is a major, frequent concern in extensible soft- ware systems such as Java Virtual Machines and the Com- mon Language Runtime. These systems aim to enable simple, classic applets and also, for example, distributed applications, Web services, and programmable networks, with appropriate security expectations. Accordingly, they feature elaborate constructs and mechanisms for associ- ating rights with code, including a technique for determin- ing the run-time rights of a piece of code as a function of the state of the execution stack. These mechanisms pre- vent many security holes, but they are inherently partial and they have proved difﬁcult to use reliably.  We motivate and describe a new model for assigning rights to code: in short, the run-time rights of a piece of code are determined by examining the attributes of any pieces of code that have run (including their origins) and any explicit requests to augment rights. This history- based model addresses security concerns while avoiding pitfalls. We analyze the model in detail; in particular, we discuss its relation to the stack-based model and to the policies and mechanisms of underlying operating systems, and we consider implementation techniques. In support of the model, we also introduce and implement high-level constructs for security, which should be incorporated in libraries or (even better) in programming languages.  1 
 Security vulnerabilities often result from buffer over- ﬂows. A testing technique that instruments programs with code that keeps track of memory buffers, and checks arguments to functions to determine if they satisfy cer- tain conditions, warns when a buffer overﬂow may oc- cur. It does so when executed with ”normal” test data as opposed to test data designed to trigger buffer over- ﬂows. A tool using this method was developed and eval- uated by testing three widely used, open source software packages. This evaluation shows that the tool is useful for ﬁnding buffer overﬂow ﬂaws, that it has a low false positive rate, and compares well with other techniques.  1 
 This paper presents SiRiUS, a secure ﬁle system de- signed to be layered over insecure network and P2P ﬁle systems such as NFS, CIFS, OceanStore, and Yahoo! Briefcase. SiRiUS assumes the network storage is un- trusted and provides its own read-write cryptographic ac- cess control for ﬁle level sharing. Key management and revocation is simple with minimal out-of-band communi- cation. File system freshness guarantees are supported by SiRiUS using hash tree constructions. SiRiUS contains a novel method of performing ﬁle random access in a cryp- tographic ﬁle system without the use of a block server. Ex- tensions to SiRiUS include large scale group sharing us- ing the NNL key revocation construction. Our implemen- tation of SiRiUS performs well relative to the underlying ﬁle system despite using cryptographic operations.  1. 
 The size and complexity of software systems is growing, increasing the number of bugs. Many of these bugs consti- tute security vulnerabilities. Most common of these bugs is the buffer overﬂow vulnerability. In this paper we im- plement a testbed of 20 different buffer overﬂow attacks, and use it to compare four publicly available tools for dynamic intrusion prevention aiming to stop buffer over- ﬂows. The tools are compared empirically and theoreti- cally. The best tool is effective against only 50% of the attacks and there are six attack forms which none of the tools can handle.  Keywords: security intrusion; buffer overﬂow; intrusion prevention; dynamic analysis  1 
 System call interposition is a powerful method for reg- In recent ulating and monitoring application behavior. years, a wide variety of security tools have been developed that use this technique. This approach brings with it a host of pitfalls for the unwary implementer that if overlooked can allow his tool to be easily circumvented. To shed light on these problems, we present the lessons we learned in the course of several design and implementation cycles with our own system call interposition-based sandboxing tool. We ﬁrst present some of the problems and pitfalls we encountered, including incorrectly replicating OS seman- tics, overlooking indirect paths to resources, race condi- tions, incorrectly subsetting a complex interface, and side effects of denying system calls. We then present some practical solutions to these problems, and provide general principles for avoiding the difﬁculties we encountered.  1 
 Denial of Service (DoS) attacks are a serious threat for the Internet. DoS attacks can consume memory, CPU, and network resources and damage or shut down the opera- tion of the resource under attack (victim). The quality of service (QoS) enabled networks, which offer different lev- els of service, are vulnerable to QoS attacks as well as DoS attacks. The aim of a QoS attack is to steal network resources, e.g., bandwidth, or to degrade the service per- ceived by users. We present a classiﬁcation and a brief explanation of the approaches used to deal with the DoS and QoS attacks. Furthermore, we propose network mon- itoring techniques to detect service violations and to infer DoS attacks. Finally, a quantitative comparison among all schemes is conducted, in which, we highlight the merits of each scheme and estimate the overhead (both process- ing and communication) introduced by it. The comparison provides guidelines for selecting the appropriate scheme, or a combination of schemes, based on the requirements and how much overhead can be tolerated.  1. 
 Today’s architectures for intrusion detection force the IDS designer to make a difﬁcult choice. If the IDS re- sides on the host, it has an excellent view of what is hap- pening in that host’s software, but is highly susceptible to attack. On the other hand, if the IDS resides in the net- work, it is more resistant to attack, but has a poor view of what is happening inside the host, making it more suscep- tible to evasion. In this paper we present an architecture that retains the visibility of a host-based IDS, but pulls the IDS outside of the host for greater attack resistance. We achieve this through the use of a virtual machine monitor. Using this approach allows us to isolate the IDS from the monitored host but still retain excellent visibility into the host’s state. The VMM also offers us the unique ability to completely mediate interactions between the host soft- ware and the underlying hardware. We present a detailed study of our architecture, including Livewire, a prototype implementation. We demonstrate Livewire by implement- ing a suite of simple intrusion detection policies and using them to detect real attacks.  1 
 In this work we revisit and formally study the notion of proxy cryptography. Intuitively, various proxy func- tions allow two cooperating parties F (the “FBI”) and P (the “proxy”) to duplicate the functionality available to the third party U (the “user”), without being able to perform this functionality on their own (without cooperation). The concept is closely related to the notion of threshold cryp- tography, except we deal with only two parties P and F , and place very strict restrictions on the way the operations are performed (which is done for the sake of efﬁciency, us- ability and scalability). For example, for decryption (resp. signature) P (F ) sends a single message to F (P ), after which the latter can decrypt (sign) the message. Our for- mal modeling of proxy cryptography signiﬁcantly general- izes, simpliﬁes and simultaneously clariﬁes the model of “atomic proxy” suggested by Blaze and Strauss [4]. In particular, we deﬁne bidirectional and unidirectional vari- ants of our model1, and show extremely simple generic so- lutions for proxy signature and encryption in these models. We also give more efﬁcient solutions for several speciﬁc schemes. We conclude that proxy cryptography is a rela- tively simple concept to satisfy when looked from the cor- rect and formal standpoint.  1 
We study proactive two-party signature schemes in the con- text of user authentication. A proactive two-party signa- ture scheme (P2SS) allows two parties—the client and the server—jointly to produce signatures and periodically to re- fresh their sharing of the secret key. The signature genera- tion remains secure as long as both parties are not compro- mised between successive refreshes. We construct the ﬁrst such proactive scheme based on the discrete log assump- tion by efﬁciently transforming Schnorr’s popular signature scheme into a P2SS. We also extend our technique to the signature scheme of Guillou and Quisquater (GQ), provid- ing two practical and efﬁcient P2SSs that can be proven secure in the random oracle model under standard discrete log or RSA assumptions.  We demonstrate the usefulness of P2SSs (as well as our speciﬁc constructions) with a new user authentication mechanism for the Self-certifying File System (SFS) [28]. Based on a new P2SS we call 2Schnorr, the new SFS au- thentication mechanism lets users register the same public key in many different administrative realms, yet still recover easily if their passwords are compromised. Moreover, an audit trail kept by a secure authentication server tells users exactly what ﬁle servers an attacker may have accessed— including even accounts the user may have forgotten about.  1. 
 Providing authentication mechanisms for IP-Multicast streams is paramount for the development of large scale commercial multicast content delivery applications. This need is particularly strong for the delivery of real time content, such as live video/audio news events or ﬁnancial stock quote distribution. However, this turns out to be a quite challenging problem for many reasons. First, the au- thentication of the multicast data must be veriﬁable by a potentially very large number of untrusted recipients. Sec- ond, since multicast communication protocols are almost always best effort, the authentication mechanisms needs to authenticate received content despite the potential loss of some packets. Finally, the authentication mechanism needs to be efﬁcient enough to cope with real time data and should have a small communication overhead.  We propose a new multicast authentication scheme de- signed to authenticate real time multicast packet streams with a potentially unlimited number of recipients. This scheme provides both integrity and nonrepudiation of ori- gin, and in a majority of situations, it performs with less overhead in bytes per packet than previously proposed practical real time stream authentication schemes.  1 
 Broadcast authentication is a fundamental security service in distributed sensor networks. A scheme named (cid:22)TESLA has been proposed for e(cid:14)cient broad- cast authentication in such networks. However, (cid:22)TESLA requires initial distribution of certain in- formation based on unicast between the base sta- tion and each sensor node before the actual authen- tication of broadcast messages. Due to the limited bandwidth in wireless sensor networks, this initial unicast-based distribution severely limits the applica- tion of (cid:22)TESLA in large sensor networks. This paper presents a novel technique to replace the unicast-based initialization with a broadcast-based one. As a result, (cid:22)TESLA can be used in a sensor network with a large amount of sensors, as long as the message from the base station can reach these sensor nodes. This pa- per further explores several techniques that improve the performance, the robustness, as well as the secu- rity of the proposed method. The resulting protocol satis(cid:12)es several nice properties, including low over- head, tolerance of message loss, scalability to large networks, and resistance to replay attacks as well as some known Denial of Service (DOS) attacks.  1. 
