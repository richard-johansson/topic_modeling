 We present a new solution to the problem of determin- ing the path a packet traversed over the Internet (called the traceback problem) during a denial of service attack. Previous solutions to this problem have suffered from com- binatorial explosion, and are unable to scale to realisti- cally sized networks. This paper reframes the traceback problem as a polynomial reconstruction problem and uses techniques from algebraic coding theory to provide ro- bust methods of transmission and reconstruction. We also present an implementation of one promising parameteri- zation that is efﬁcient, backwards compatible, and incre- mentally deployable.  1. 
 We propose a new scheme for authenticating streamed data delivered in real-time over an insecure network. The difﬁculty of signing live streams is twofold. First, authen- tication must be efﬁcient so the stream can be processed without delay. Secondly, authentication must be possible even if some packets in the sequence are missing. Streams of audio or video provide a good example. They must be processed in real-time and are commonly exchanged over UDP, with no guarantee that every packet will be deliv- ered. Existing solutions to the problem of signing streams have been designed to resist worst-case packet loss. In practice however, network loss is not malicious but occurs in patterns of consecutive packets known as bursts. Based on this realistic model of network loss, we propose an authentication scheme for streams which achieves better performance as well as much lower communication over- head than existing solutions. We have implemented our constructions as plug-ins to the RealSystem platform from Real Networks to authenticate audio and video streams.  Keywords: authentication, non-repudiation, streams.  1. 
 CellCase is a commercial high-speed encryptor for Asynchronous Transfer Mode (ATM) networks, available since 1997. It provides data conﬁdentiality and entity au- thentication at the ATM layer, encrypting ATM cell pay- loads at rates from T1 (1.5 Mb/s) to OC-12c (622 Mb/s). Though deployed prior to the adoption of the ATM Forum Security Speciﬁcation (1999), CellCase implements many of the mechanisms deﬁned by that standard. In this pa- per, we describe how CellCase is deployed in actual net- works, as well as customer experience with services such as counter-mode encryption, key exchange, and key up- date. Based on this experience, we also discuss possible changes to the ATM Forum speciﬁcation.  1 
 One of the main challenges of securing multicast com- munication is source authentication, or enabling receivers of multicast data to verify that the received data origi- nated with the claimed source and was not modiﬁed en- route. The problem becomes more complex in common settings where other receivers of the data are not trusted, and where lost packets are not retransmitted.  Several source authentication schemes for multicast have been suggested in the past, but none of these schemes is satisfactorily efﬁcient in all prominent parameters. We recently proposed a very efﬁcient scheme, TESLA, that is based on initial loose time synchronization between the sender and the receivers, followed by delayed release of keys by the sender.  This paper proposes several substantial modiﬁcations and improvements to TESLA. One modiﬁcation allows re- ceivers to authenticate most packets as soon as they arrive (whereas TESLA requires buffering packets at the receiver side, and provides delayed authentication only). Other modiﬁcations improve the scalability of the scheme, re- duce the space overhead for multiple instances, increase its resistance to denial-of-service attacks, and more.  1 
 In this paper we present protocols for distributed certiﬁed e-mail, which use encryption to ensure both conﬁdentiality and fairness. As with other protocols for certiﬁed e-mail, ours achieve fairness by plac- ing trust on an external entity, referred to as the Trusted Third Party (TTP). The TTP can become a bottleneck, however, and we explore scenarios that support a distributed TTP, in the context of both off-line and online protocols. With several servers dividing the TTP respon- sibilities, the level of conﬁdence placed in individual servers can be reduced without compromising the TTP’s overall trust. Keywords: Secure E-commerce, Fair Exchange, Certiﬁed E-mail,  Semi-trusted TTP.  1 
 This paper presents a new password authentica- tion and key agreement protocol called AMP in a provable manner. The intrinsic problem with pass- word authentication is a password, associated with each user, has low entropy so that (1) the password is hard to transmit securely over an insecure channel and (2) the password ﬁle is hard to protect. Our so- lution to this complex problem is the ampliﬁed pass- word proof idea along with the ampliﬁed password ﬁle. A party commits the high entropy information and ampliﬁes her password with that information in the ampliﬁed password proof. She never shows any information except that she knows it for her proof. Our ampliﬁed password proof idea is similar to the zero-knowledge proof in that sense. A server stores ampliﬁed veriﬁers in the ampliﬁed password ﬁle that is secure against a server ﬁle compromise and a dic- tionary attack. AMP mainly provides the password- veriﬁer based authentication and the Difﬁe-Hellman based key agreement, securely and efﬁciently. AMP is simple and actually the most efﬁcient protocol among the related protocols.  1. 
 Most organizations use several security policies to con- trol different systems and data, comprising in this way a global complex policy. These security policies are often scattered over different environments, each one with its own security model and domain of administration, mak- ing them difﬁcult to administer and understand. More- over, some applications (e.g. workﬂow), often need to cross several of these security domains and satisfy each one of their policies, which is very difﬁcult to accomplish when these policies are scattered over the organization, in conﬂict with each other and frequently expressed in differ- ent models.  This work presents a security policy language that al- lows organizations to express and keep their global se- curity policies in one single description. Although ﬂexible enough to express simultaneously several types of complex security policies, this language can be easily implemented by an event monitor.  The proposed language can express the concepts of per- mission and prohibition, and some restricted forms of obligation. We show how to express and implement obli- gation using the transaction concept, and how to use obli- gation to express information ﬂow policies together with other complex security policies. We also address the prob- lem of conﬂicting policies and show how to efﬁciently enforce the security policies expressed by the language with a security event monitor, including history-based and obligation-based security policies.  1. 
Most organizations use several security policies to control different systems and data, comprising in this way a global complex policy. These security policies are often scattered over different environments, each one with its own security model and domain of administration, making them difficult to administer and understand. Moreover, some applications (e.g. workflow), often need to cross several of these security domains and satisfy each one of their policies, which is very difficult to accomplish when these policies are scattered over the organization, in conflict with each other and frequently expressed in different models. This work presents a security policy language that allows organizations to express and keep their global security policies in one single description. Although flexible enough to expresssimultaneously several types of complex security policies, this language can be easily implemented by an event monitor. The proposed language can express the concepts of permission and prohibition, and some restricted forms of obligation. We show how to express and implement obligation using the transaction concept, and how to use obligation to express information flow policies together with other complex security policies. We also address the problem of conflicting policies and show how to efficiently enforce the security policies expressed by the language with a security event monitor, including history-based and obligation-based security policies.
 Security policy is increasingly being used as a vehicle for specifying complex entity relationships. When used to de- ﬁne group security, policy must be extended to state the en- tirety of the security context. For this reason, the policy re- quirements of secure groups are more complex than found in traditional peer communication; group policies convey information about associations greater and more abstract than their pair-wise counterparts. This paper identiﬁes and illustrates universal requirements of secure group pol- icy and reasons about the adherence of the Group Secu- rity Association Key Management Protocol (GSAKMP) to these principles.  1. 
 IPsec is the standard suite of protocols for network- layer conﬁdentiality and authentication of Internet traf- ﬁc. The IPsec protocols, however, do not address the policies for how protected trafﬁc should be handled at se- curity endpoints. This paper introduces an efﬁcient pol- icy management scheme for IPsec, based on the princi- ples of trust management. A compliance check is added to the IPsec architecture that tests packet ﬁlters proposed when new security associations are created for confor- mance with the local security policy, based on credentials presented by the peer host. Security policies and creden- tials can be quite sophisticated (and speciﬁed in the trust- management language), while still allowing very efﬁcient packet-ﬁltering for the actual IPsec trafﬁc. We present a practical, portable implementation of this design, based on the KeyNote trust-management language, that works with a variety of Unix-based IPsec implementations.  1. 
 In general, building and validating a certification  path connecting a trust anchor to a target can be a very time- consuming  process.  As  such,  any  optimizations  are valuable. Certification paths are commonly built from the target  to  the  trust  anchor  (“building  in  the  forward direction”)  or  from  the  trust  anchor  to  the  target (“building in the reverse direction”). This paper presents a  comparison  of  these  two  approaches,  analyzes  the advantages  and  disadvantages  of  each  approach,  and concludes  that  building  in  the  reverse  direction  is  often more effective than building in the forward direction.  1. 
 Among the different approaches to distributed computing, the Jini technology provides a number of very promising methods for attacking the fundamental problems involved. Programs built according to the Jini principles will be able to function and survive in highly dynamic network environ- ments, allowing applications to adapt their behaviour to the requirements of the current context. Unfortunately, the security problems that are bound to be present in any large scale deployment of Jini are not adequately addressed by either the current revisions of Jini technology or the un- derlying Java security solutions. In particular, the solu- tions proposed so far are either bound to a speciﬁc com- munication protocol—thereby hampering the protocol in- dependence of Jini—or rely on centralized security servers, thereby losing the beneﬁts of the ad hoc nature of Jini.  In this paper, we present results of our research that act as stepping stones towards a fully decentralized, complete In particular, we describe our Jini security architecture. experimental implementation that separates the Java 2 ac- cess permissions of Jini clients, service proxies, and ser- vices, while allowing natural delegation of Java 2 permis- sions between Jini enabled devices. Our solution integrates seamlessly to the underlying Java 2 security, and allows all of Jini’s beneﬁts to be utilized in a secure way.  1  
 Language runtime systems are increasingly being em- bedded in systems to support runtime extensibility via mo- bile code. Such systems raise a number of concerns when the code running in such systems is potentially buggy or untrusted. While sophisticated access controls have been designed for mobile code and are shipping as part of com- mercial systems such as Java, there is no support for ter- minating mobile code short of terminating the entire lan- guage runtime. This paper presents a concept called “soft termination” which can be applied to virtually any mobile code system. Soft termination allows mobile code threads to be safely terminated while preserving the stability of the language runtime. In addition, function bodies can be permanently disabled, thwarting attacks predicated on system threads eventually calling untrusted functions. We present a formal design for soft termination and an imple- mentation of it for Java, built using Java bytecode rewrit- ing, and demonstrating reasonable performance (3-25% slowdowns on benchmarks).  1. 
 Cryptography is a powerful tool for building secure dis- tributed systems, albeit at substantial computational cost. This is especially true for public key cryptography. Con- ventional wisdom dictates that cryptography must be done locally in order to be secure. We argue for an approach in which public key cryptographic operations are provided as a network service. This service operates over long- lived associations secured by symmetric cryptography. This network architecture amortizes the cost of special- purpose cryptographic hardware across many users. We describe the implementation of such a system, and perfor- mance results we obtained.  1. 
 Cryptography is a powerful tool for building secure distributed systems, albeit at substantial computational cost. This is especially true for public key cryptography. Conventional wisdom dictates that cryptography must be done locally in order to be secure. We argue for an approach in which public key cryptographic operations are provided as a network service. This service operates over longlived associations secured by symmetric cryptography. This network architecture amortizes the cost of specialpurpose cryptographic hardware across many users. We describe the implementation of such a system, and performance results we obtained.
